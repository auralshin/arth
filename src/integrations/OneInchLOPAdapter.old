// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import { SafeERC20, IERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { IOrderMixin } from "@1inch/limit-order-protocol-contract/interfaces/IOrderMixin.sol";
import { TakerTraits } from "@1inch/limit-order-protocol-contract/libraries/TakerTraitsLib.sol";

interface IWETH {
    function deposit() external payable;
    function withdraw(uint256) external;
}

contract OneInchLOPAdapter {
    using SafeERC20 for IERC20;

    error OrderFillFailed();
    error InvalidParameters();
    error NotRouter();

    event OrderFilled(bytes32 indexed orderHash, uint256 makingAmount, uint256 takingAmount);
    event Swept(address indexed token, address indexed to, uint256 amount);
    event Refunded(address indexed token, address indexed to, uint256 amount);

    address public immutable LOP;      // 1inch LOP v4
    address public immutable WETH;     // WETH (optional but recommended)
    address public immutable ROUTER;   // your IRS Router (optional hard-gate)

    constructor(address lop, address weth, address router) {
        if (lop == address(0) || router == address(0)) revert InvalidParameters();
        LOP    = lop;
        WETH   = weth;            // can be zero on L2s without WETH path
        ROUTER = router;
    }

    modifier onlyRouter() {
        if (msg.sender != ROUTER) revert NotRouter();
        _;
    }

    function _isWETH(IERC20 t) internal view returns (bool) {
        return WETH != address(0) && address(t) == WETH;
    }

    function _forceApprove(IERC20 token, address spender, uint256 amount) internal {
        // Safe pattern for non-compliant ERC20s
        token.forceApprove(spender, 0);
        if (amount > 0) token.forceApprove(spender, amount);
    }

    /// @notice Fill a 1inch order (no extra args), sweep makerAsset to Router, refund taker leftovers to `refundTo`
    /// @param order        1inch v4 order struct (official type)
    /// @param signature    maker signature
    /// @param amount       taker-driven amount
    /// @param takerTraits  flags/threshold (official type)
    /// @param takerAsset   token we pay (WETH for ETH path)
    /// @param pullFromCaller amount of takerAsset to pull from msg.sender into this adapter before fill (0 to skip)
    /// @param makerAsset   expected maker token; must equal order.makerAsset
    /// @param sweepTo      recipient of makerAsset (your Router)
    /// @param refundTo     recipient of taker leftovers (typically Router too)
    function fillContractOrder(
        IOrderMixin.Order calldata order,
        bytes calldata signature,
        uint256 amount,
        TakerTraits takerTraits,
        IERC20 takerAsset,
        uint256 pullFromCaller,
        IERC20 makerAsset,
        address sweepTo,
        address refundTo
    )
        external
        payable
        onlyRouter
        returns (uint256 making, uint256 taking, bytes32 orderHash)
    {
        if (amount == 0 || sweepTo == address(0) || refundTo == address(0)) revert InvalidParameters();
        if (address(makerAsset) != order.makerAsset) revert InvalidParameters();

        // Fund taker side
        uint256 preTakerBal = takerAsset.balanceOf(address(this));

        if (msg.value > 0) {
            // ETH path requires takerAsset == WETH
            if (!_isWETH(takerAsset)) revert InvalidParameters();
            IWETH(WETH).deposit{value: msg.value}();
        }
        if (pullFromCaller > 0) {
            takerAsset.safeTransferFrom(msg.sender, address(this), pullFromCaller);
        }

        // Approve LOP to spend *up to current balance*
        uint256 spendCap = takerAsset.balanceOf(address(this)) - preTakerBal;
        if (spendCap > 0) _forceApprove(takerAsset, LOP, spendCap);

        // Fill on 1inch
        try IOrderMixin(LOP).fillContractOrder(order, signature, amount, takerTraits)
            returns (uint256 m, uint256 t, bytes32 h)
        {
            making = m; taking = t; orderHash = h;
            emit OrderFilled(h, m, t);
        } catch {
            // reset approval before bubbling up
            if (spendCap > 0) _forceApprove(takerAsset, LOP, 0);
            revert OrderFillFailed();
        }

        // Reset approval
        if (spendCap > 0) _forceApprove(takerAsset, LOP, 0);

        // Sweep maker side to Router
        _sweepAll(makerAsset, sweepTo);

        // Refund any taker leftovers (ERC20 or WETH) to `refundTo`
        _refundTakerLeftovers(takerAsset, refundTo);
    }

    /// @notice Same as above but forwards taker args (permit/extension/interaction)
    function fillContractOrderArgs(
        IOrderMixin.Order calldata order,
        bytes calldata signature,
        uint256 amount,
        TakerTraits takerTraits,
        bytes calldata takerArgs,
        IERC20 takerAsset,
        uint256 pullFromCaller,
        IERC20 makerAsset,
        address sweepTo,
        address refundTo
    )
        external
        payable
        onlyRouter
        returns (uint256 making, uint256 taking, bytes32 orderHash)
    {
        if (amount == 0 || sweepTo == address(0) || refundTo == address(0)) revert InvalidParameters();
        if (address(makerAsset) != order.makerAsset) revert InvalidParameters();

        uint256 preTakerBal = takerAsset.balanceOf(address(this));

        if (msg.value > 0) {
            if (!_isWETH(takerAsset)) revert InvalidParameters();
            IWETH(WETH).deposit{value: msg.value}();
        }
        if (pullFromCaller > 0) {
            takerAsset.safeTransferFrom(msg.sender, address(this), pullFromCaller);
        }

        uint256 spendCap = takerAsset.balanceOf(address(this)) - preTakerBal;
        if (spendCap > 0) _forceApprove(takerAsset, LOP, spendCap);

        try IOrderMixin(LOP).fillContractOrderArgs(order, signature, amount, takerTraits, takerArgs)
            returns (uint256 m, uint256 t, bytes32 h)
        {
            making = m; taking = t; orderHash = h;
            emit OrderFilled(h, m, t);
        } catch {
            if (spendCap > 0) _forceApprove(takerAsset, LOP, 0);
            revert OrderFillFailed();
        }

        if (spendCap > 0) _forceApprove(takerAsset, LOP, 0);

        _sweepAll(makerAsset, sweepTo);
        _refundTakerLeftovers(takerAsset, refundTo);
    }

    // --- helpers ---

    function _sweepAll(IERC20 token, address to) internal {
        uint256 bal = token.balanceOf(address(this));
        if (bal > 0) {
            token.safeTransfer(to, bal);
            emit Swept(address(token), to, bal);
        }
    }

    function _refundTakerLeftovers(IERC20 takerAsset, address to) internal {
        uint256 bal = takerAsset.balanceOf(address(this));
        if (bal > 0) {
            takerAsset.safeTransfer(to, bal);
            emit Refunded(address(takerAsset), to, bal);
        }
    }

    receive() external payable {}
}
contract OneInchLOPAdapter {
    using SafeERC20 for IERC20;

    /// @notice Errors
    error OrderFillFailed();
    error InvalidParameters();
    error SweepFailed();

    /// @notice Events
    event OrderFilled(bytes32 indexed orderHash, uint256 makingAmount, uint256 takingAmount);
    event Swept(address indexed token, address indexed to, uint256 amount);

    /// @notice Immutable addresses
    address public immutable LOP;     // 1inch LOP v4 contract
    address public immutable WETH;    // WETH contract (optional for ETH handling)

    constructor(address lop, address weth) {
        if (lop == address(0)) revert InvalidParameters();
        LOP = lop;
        WETH = weth;
    }

    /// @notice Helper to safely approve tokens
    /// @dev Sets to 0 first to handle tokens that require zero approval before setting new amount
    function _safeApprove(IERC20 token, address spender, uint256 amount) internal {
        token.forceApprove(spender, 0);
        if (amount > 0) token.forceApprove(spender, amount);
    }

    /// @notice Check if token is WETH
    function _isWETH(IERC20 token) internal view returns (bool) {
        return WETH != address(0) && address(token) == WETH;
    }

    /// @notice Fill order using fillContractOrder (no extra args)
    /// @param order The limit order structure
    /// @param signature The maker's signature
    /// @param amount Taker amount to fill
    /// @param takerTraits Encoded taker preferences and thresholds  
    /// @param takerAsset Token we pay to the maker
    /// @param takerAssetMaxSpend Maximum amount to approve for LOP spending
    /// @param sweepTo Address to receive the maker asset (typically the Router)
    /// @param makerAsset Expected maker token for sweep validation
    /// @return making Actual amount of makerAsset received
    /// @return taking Actual amount of takerAsset paid
    /// @return orderHash Hash of the filled order
    function fillContractOrder(
        ILimitOrderProtocol.Order calldata order,
        bytes calldata signature,
        uint256 amount,
        uint256 takerTraits,
        IERC20 takerAsset,
        uint256 takerAssetMaxSpend,
        address sweepTo,
        IERC20 makerAsset
    )
        external
        payable
        returns (uint256 making, uint256 taking, bytes32 orderHash)
    {
        if (amount == 0 || sweepTo == address(0)) revert InvalidParameters();

        // Optional: wrap ETH -> WETH if msg.value is used as taker asset
        if (msg.value > 0) {
            if (!_isWETH(takerAsset)) revert InvalidParameters();
            IWETH(WETH).deposit{value: msg.value}();
        }

        // Temporary approve LOP to spend takerAsset
        if (takerAssetMaxSpend > 0) _safeApprove(takerAsset, LOP, takerAssetMaxSpend);

        try ILimitOrderProtocol(LOP).fillContractOrder(order, signature, amount, takerTraits)
            returns (uint256 m, uint256 t, bytes32 h)
        {
            making = m;
            taking = t;
            orderHash = h;
            emit OrderFilled(h, m, t);
        } catch {
            revert OrderFillFailed();
        }

        // Remove approval
        if (takerAssetMaxSpend > 0) _safeApprove(takerAsset, LOP, 0);

        // Sweep makerAsset to the recipient (typically Router)
        _sweep(makerAsset, sweepTo);
    }

    /// @notice Fill order using fillContractOrderArgs (forward permit/extension/interaction bundle)
    /// @param order The limit order structure
    /// @param signature The maker's signature
    /// @param amount Taker amount to fill
    /// @param takerTraits Encoded taker preferences and thresholds
    /// @param args Arbitrary taker args: (target, extension, interaction, permit...)
    /// @param takerAsset Token we pay to the maker
    /// @param takerAssetMaxSpend Maximum amount to approve for LOP spending
    /// @param sweepTo Address to receive the maker asset
    /// @param makerAsset Expected maker token for sweep validation
    /// @return making Actual amount of makerAsset received
    /// @return taking Actual amount of takerAsset paid
    /// @return orderHash Hash of the filled order
    function fillContractOrderArgs(
        ILimitOrderProtocol.Order calldata order,
        bytes calldata signature,
        uint256 amount,
        uint256 takerTraits,
        bytes calldata args,
        IERC20 takerAsset,
        uint256 takerAssetMaxSpend,
        address sweepTo,
        IERC20 makerAsset
    )
        external
        payable
        returns (uint256 making, uint256 taking, bytes32 orderHash)
    {
        if (amount == 0 || sweepTo == address(0)) revert InvalidParameters();

        if (msg.value > 0) {
            if (!_isWETH(takerAsset)) revert InvalidParameters();
            IWETH(WETH).deposit{value: msg.value}();
        }

        if (takerAssetMaxSpend > 0) _safeApprove(takerAsset, LOP, takerAssetMaxSpend);

        try ILimitOrderProtocol(LOP).fillContractOrderArgs(order, signature, amount, takerTraits, args)
            returns (uint256 m, uint256 t, bytes32 h)
        {
            making = m;
            taking = t;
            orderHash = h;
            emit OrderFilled(h, m, t);
        } catch {
            revert OrderFillFailed();
        }

        if (takerAssetMaxSpend > 0) _safeApprove(takerAsset, LOP, 0);

        _sweep(makerAsset, sweepTo);
    }

    /// @notice Sweep tokens from this contract to recipient
    /// @param token Token to sweep (address(0) for ETH sweep - not recommended)
    /// @param to Recipient address
    function _sweep(IERC20 token, address to) internal {
        if (address(token) != address(0)) {
            uint256 bal = token.balanceOf(address(this));
            if (bal > 0) {
                token.safeTransfer(to, bal);
                emit Swept(address(token), to, bal);
            }
            return;
        }
        // Optional: ETH sweep logic could go here but not recommended for IRS
    }

    /// @notice Create basic taker traits for simple fills
    /// @param threshold Maximum amount taker is willing to spend (for takingAmount-based fills)
    /// @param makingAmountMode True if driving by making amount, false for taking amount
    /// @return takerTraits Encoded taker traits
    function createBasicTakerTraits(uint256 threshold, bool makingAmountMode) 
        external 
        pure 
        returns (uint256 takerTraits) 
    {
        uint256 traits = threshold;
        if (makingAmountMode) {
            traits |= (1 << 255); // Set MAKER_AMOUNT_FLAG
        }
        return traits;
    }

    /// @notice Get the maker asset balance held by this adapter
    /// @param asset The ERC20 token to check
    /// @return balance Current balance of the asset
    function getAssetBalance(IERC20 asset) external view returns (uint256 balance) {
        return asset.balanceOf(address(this));
    }

    /// @notice Emergency function to recover tokens sent to this contract
    /// @param token The token to recover
    /// @param to The recipient address
    /// @param amount The amount to recover
    /// @dev This is a safety function in case tokens get stuck
    function recoverToken(IERC20 token, address to, uint256 amount) external {
        // Only allow recovery to msg.sender for safety
        require(to == msg.sender, "Can only recover to caller");
        token.safeTransfer(to, amount);
    }

    /// @notice Allow contract to receive ETH (for WETH unwrapping)
    receive() external payable {}
}